// Generated by dts-bundle v0.7.3
// Dependencies for this module:
//   ../../react
//   ../../@brightsign/bsdatamodel
//   ../../redux
//   ../../@brightsign/assetpool
//   ../../@brightsign/ba-context-model
//   ../../@brightsign/bscore

import * as React from 'react';
import { DmState } from '@brightsign/bsdatamodel';
import { DmcDataFeed } from '@brightsign/bsdatamodel';
import { Store } from 'redux';
import { Action, Dispatch, ActionCreator } from 'redux';
import { Reducer } from 'redux';
import { Asset } from '@brightsign/assetpool';
import { BaContextModelState } from '@brightsign/ba-context-model';
import { BsDmId } from '@brightsign/bsdatamodel';
import { DataFeedUsageType } from '@brightsign/bscore';
import { BsAssetLocator } from '@brightsign/bscore';
import { DmZone } from '@brightsign/bsdatamodel';
import { DmMediaState } from '@brightsign/bsdatamodel';

/** @module Controller:index */

/** @module Model:index */

/** @module Selector:index */

/** @module Types:index */

/** @private */
export interface BsPpProps {
    autoschedule: PpSchedule | null;
    bsdm: DmState;
    hsmMap: HsmMap;
    onInitPresentation: () => BsPpVoidThunkAction;
}
export const BsPp: import("react-redux").ComponentClass<Pick<BsPpProps, never>> & {
    WrappedComponent: React.ComponentType<BsPpProps>;
};

export const initPresentation: () => BsPpVoidThunkAction;
export const openSign: (presentationName: string) => (dispatch: BsPpDispatch, getState: () => BsPpState) => any;

export function retrieveDataFeed(state: any, bsdm: DmState, dataFeed: DmcDataFeed): Promise<ArFeed>;
export function readCachedFeed(state: any, bsdmDataFeed: DmcDataFeed): Promise<ArFeed | null>;
export function processFeed(bsdmDataFeed: DmcDataFeed, feed: ArFeed): BsPpVoidPromiseThunkAction;
export function downloadMRSSFeedContent(arDataFeed: ArMrssFeed): (dispatch: any, getState: any) => void;
export function downloadContentFeedContent(arDataFeed: ArContentFeed): (dispatch: any, getState: any) => void;
export function processTextDataFeed(bsdmDataFeed: DmcDataFeed, textFeed: ArFeed): BsPpVoidPromiseThunkAction;
export function parseSimpleRSSFeed(bsdmDataFeed: DmcDataFeed, textFeed: ArFeed): BsPpVoidThunkAction;
export function getFeedCacheRoot(state: any): string;
export function feedIsMrss(feed: any): boolean;

export let _bsPpStore: Store<BsPpState>;
/** @private */
export function initPlayer(store: Store<BsPpState>): (dispatch: BsPpDispatch) => void;
/** @private */
export function launchHsm(): (dispatch: BsPpDispatch) => void;
export const addHsmEvent: (event: HsmEventType) => BsPpVoidThunkAction;

/** @module Model:base */
/** @private */
export interface BsPpModelBaseAction extends Action {
    type: string;
    payload: {} | null;
    error?: boolean;
    meta?: {};
}
/** @private */
export interface BsPpModelAction<T> extends BsPpModelBaseAction {
    payload: T;
}
/** @private */
export type BsPpModelActionCreator<T> = ActionCreator<BsPpModelAction<T>>;
export type BsPpModelThunkAction<T> = (dispatch: BsPpDispatch, getState: () => BsPpModelState, extraArgument: undefined) => T;
export interface BsPpBaseAction extends Action {
    type: string;
    payload: {} | null;
    error?: boolean;
    meta?: {};
}
export interface BsPpAction<T> extends BsPpBaseAction {
    payload: T;
}
export type BsPpDispatch = Dispatch<BsPpState>;
export type BsPpVoidThunkAction = any;
export type BsPpStringThunkAction = any;
export type BsPpVoidPromiseThunkAction = any;
export type BsPpThunkAction<T> = any;
export type BsPpAnyPromiseThunkAction = any;
export type BsPpActionCreator<T> = ActionCreator<BsPpAction<T>>;
export interface BsPpModelBatchAction extends Action {
    type: string;
    payload: BsPpBaseAction[];
}

export const ADD_DATA_FEED = "ADD_DATA_FEED";
export function addDataFeed(dataFeedId: string, arDataFeed: ArDataFeed): {
    type: string;
    payload: {
        dataFeedId: string;
        arDataFeed: ArDataFeed;
    };
};
export const dataFeedReducer: (state: ArDataFeedMap | undefined, action: any) => ArDataFeedMap;
/** @private */
export const isValidDataFeedState: (state: any) => boolean;

/** @module Model:template */
export const ADD_HSM: string;
export const UPDATE_HSM_PROPERTIES: string;
export const SET_HSM_TOP: string;
export const SET_HSM_INITIALIZED: string;
export const ADD_HSTATE = "ADD_HSTATE";
export const SET_MEDIA_H_STATE_TIMEOUT_ID = "SET_MEDIA_H_STATE_TIMEOUT_ID";
export const SET_ACTIVE_HSTATE = "SET_ACTIVE_HSTATE";
export const QUEUE_HSM_EVENT = "QUEUE_HSM_EVENT";
export const DEQUEUE_HSM_EVENT = "DEQUEUE_HSM_EVENT";
export type AddHsmAction = BsPpAction<Partial<Hsm>>;
export function addHsm(hsm: Hsm): AddHsmAction;
export interface HsmParams {
    id: string;
    zoneId?: string;
    x?: number;
    y?: number;
    width?: number;
    height?: number;
    initialMediaStateId?: string;
    mediaStateIdToHState?: LUT;
}
export type UpdateHsmPropertiesAction = BsPpAction<HsmParams>;
export function updateHsmProperties(params: HsmParams): UpdateHsmPropertiesAction;
export type SetHsmTopAction = BsPpAction<{}>;
export function setHsmTop(hsmId: string, topStateId: string): SetHsmTopAction;
export type SetHsmInitializedAction = BsPpAction<Partial<Hsm>>;
export function setHsmInitialized(id: string, initialized: boolean): SetHsmInitializedAction;
export type SetActiveHStateAction = BsPpAction<HState | null | any>;
export function setActiveHState(hsmId: string, activeState: HState | null): SetActiveHStateAction;
export type AddHStateAction = BsPpAction<{
    id: string;
    type: HStateType;
    hsmId: string;
    superStateId: string;
    name: string;
    mediaStateId?: string;
    timeoutId?: number;
    dataFeedId?: string;
}>;
export interface AddHStateOptions {
    mediaStateId: string;
    dataFeedId?: string;
    timeoutId?: number;
}
export function addHState(hStateSpecification: HStateSpecification, options?: AddHStateOptions): AddHStateAction;
export function setMediaHStateTimeoutId(hStateId: string, timeoutId: number): any;
export type HsmEventAction = BsPpAction<HsmEventType>;
export function queueHsmEvent(event: HsmEventType): HsmEventAction;
export function dequeueHsmEvent(): BsPpBaseAction;
export const hsmReducer: import("redux").Reducer<HsmState>;
/** @private */
export const isValidHsmState: (state: any) => boolean;

/** @module Model:base */
/** @private */
export type BsUiReducer = Reducer<BsPpModelState>;
/** @private */
export const enableBatching: (reduce: (state: BsPpModelState, action: BsPpModelBaseAction) => BsPpModelState) => BsUiReducer;
export const bsPpReducer: Reducer<BsPpModelState>;
/** @private */
export function isValidBsPpModelState(state: any): boolean;
/** @private */
export function isValidBsPpModelStateShallow(state: any): boolean;

export const SET_VIDEO_ELEMENT_REF = "SET_VIDEO_ELEMENT_REF";
export type SetPlaybackAction = BsPpAction<PlaybackState>;
export const setVideoElementRef: (videoElementRef: HTMLVideoElement | null) => SetPlaybackAction;
export const playbackDefaults: PlaybackState;
export const playbackReducer: (state: PlaybackState | undefined, { type, payload }: (SetPlaybackAction)) => PlaybackState;

export const UPDATE_PRESENTATION_DATA = "UPDATE_PRESENTATION_DATA";
export const UPDATE_RUNTIME_ENVIRONMENT = "UPDATE_RUNTIME_ENVIRONMENT";
export const UPDATE_PRESENTATION_SRC_DIRECTORY = "UPDATE_PRESENTATION_SRC_DIRECTORY";
export const UPDATE_SYNC_SPEC_FILE_MAP = "UPDATE_SYNC_SPEC_FILE_MAP";
export const UPDATE_AUTOSCHEDULE = "UPDATE_AUTOSCHEDULE";
export const UPDATE_SCREEN_DIMENSIONS = "UPDATE_SCREEN_DIMENSIONS";
export type UpdatePresentationDataAction = BsPpAction<Partial<PresentationDataState>>;
export type UpdatePresentationStringAction = BsPpAction<Partial<PresentationDataState>>;
export function updatePresentationData(presentationDataState: PresentationDataState): UpdatePresentationDataAction;
export const updateRuntimeEnvironment: (runtimeEnvironment: RuntimeEnvironment) => UpdatePresentationDataAction;
export const updatePresentationSrcDirectory: (srcDirectory: string) => UpdatePresentationDataAction;
export const updatePresentationSyncSpecFileMap: (syncSpecFileMap: SyncSpecFileMap) => UpdatePresentationDataAction;
export const updatePresentationAutoschedule: (autoSchedule: PpSchedule) => UpdatePresentationDataAction;
export const updateScreenDimensions: (screenDimensions: Dimensions) => UpdatePresentationDataAction;
export const presentationDataDefaults: PresentationDataState;
export const presentationDataReducer: (state: PresentationDataState | undefined, { type, payload }: (UpdatePresentationDataAction)) => PresentationDataState;

export function getDataFeedById(state: any, dataFeedId: string): ArDataFeed | null;
export function getMrssFeedItems(feed: any): ArMrssItem[];
export function allDataFeedContentExists(state: any, dataFeed: ArMrssFeed | ArContentFeed): boolean;
export function dataFeedContentExists(state: any, dataFeed: ArMrssFeed): boolean;
export function getFeedPoolFilePathFromAsset(state: any, asset: Asset): string;

export function getHsmMap(state: any): HsmMap;
export function getHsmById(state: any, hsmId: string): Hsm;
export function getHsmByName(state: BsPpState, hsmName: string): Hsm | null;
export const getActiveStateIdByHsmId: (state: BsPpState, hsmId: string) => HState | null;
export function getHStateById(state: any, hStateId: string | null): HState | null;
export function getHStateByName(state: any, name: string | null): HState | null;
export function getHStateByMediaStateId(state: any, hsmId: string, mediaStateId: string | null): HState | null;
export function getHsmInitialized(state: any, hsmId: string): boolean;
export function getZoneHsmList(state: any): Hsm[];
export function getActiveMediaStateId(state: any, zoneId: string): string;
export function getEvents(state: any): HsmEventType[];
export const getIsHsmInitialized: (state: any) => boolean;

export function getVideoRef(state: BsPpState): HTMLVideoElement | null;

export function getRuntimeEnvironment(state: any): RuntimeEnvironment;
export function getSrcDirectory(state: any): string;
export function getScreenDimensions(state: any): Dimensions;
export const getSyncSpecFileMap: (state: BsPpState) => SyncSpecFileMap | null;
export const getAutoschedule: (state: any) => PpSchedule | null;
export function getPathFromAssetName(state: BsPpState, assetName: string): string;
export function getAssetPath(state: BsPpState, assetName: string): string;
export function getFeedPoolFilePath(state: any, hashValue: string): string;
export function feedPoolFileExists(state: any, hashValue: string): string;
export const getSyncSpecFile: (state: BsPpState, fileName: string) => Promise<object>;
export function getSyncSpecReferencedFile(fileName: string, syncSpecFileMap: SyncSpecFileMap, rootPath: string): Promise<object>;

export interface MrssDisplayItemMap {
    [hsmId: string]: ArMrssItem | null;
}

/** @module Types:base */
export class RuntimeEnvironment {
    static BrightSign: string;
    static BaconPreview: string;
    static Dev: string;
}
export type DeepPartial<T> = {
    [P in keyof T]?: DeepPartial<T[P]>;
};
export interface BsPpState {
    bsdm: DmState;
    bacdm: BaContextModelState;
    bsPlayer: BsPpModelState;
}
export interface BsPpModelState {
    hsmState: HsmState;
    presentationData: PresentationDataState;
    playback: PlaybackState;
    arDataFeeds: ArDataFeedMap;
}
export const bsPpStateFromState: (state: any) => BsPpState;
export interface LUT {
    [key: string]: any;
}
export interface BsPpBaseObject {
    id: string;
}
export interface BsPpMap<T extends BsPpBaseObject> {
    [id: string]: T;
}
export interface FileLUT {
    [fileName: string]: string;
}

export interface ArFeed {
    rss: any;
}
export interface ArDataFeedBase {
    type: string;
    id: BsDmId;
    sourceId: BsDmId;
    usage: DataFeedUsageType;
}
export interface ArTextItem {
    articleTitle: string;
    articleDescription: string;
}
export interface ArTextFeedProperties {
    textItems: ArTextItem[];
    articlesByTitle: any;
}
export interface ArMrssItem {
    guid: string;
    link: string;
    title: string;
    pubDate: string;
    duration: string;
    fileSize: string;
    medium: string;
    type: string;
    url: string;
    filePath?: string;
}
export interface ArMrssFeedProperties {
    mrssItems: ArMrssItem[];
    title: string;
    playtime: string;
    ttl: string;
    assetList: Asset[];
}
export interface ArContentFeedItem {
    name: string;
    url: string;
    medium: string;
    hash: string;
}
export interface ArContentFeedProperties {
    contentItems: ArContentFeedItem[];
    assetList: Asset[];
}
export interface ArMediaFeedItem {
    filePath: string;
    medium: string;
}
export type ArDataFeed = ArTextFeed | ArMrssFeed | ArContentFeed;
export type ArTextFeed = ArDataFeedBase & ArTextFeedProperties;
export type ArMrssFeed = ArDataFeedBase & ArMrssFeedProperties;
export type ArContentFeed = ArDataFeedBase & ArContentFeedProperties;
export interface ArDataFeedMap {
    [dataFeedId: string]: ArDataFeed;
}

export type HsmMap = BsPpMap<Hsm>;
export type HStateMap = BsPpMap<HState>;
export interface HsmState {
    hsmById: HsmMap;
    hStateById: HStateMap;
    hsmEventQueue: HsmEventType[];
}
export interface Hsm {
    id: string;
    name: string;
    type: HsmType;
    topStateId: string;
    activeStateId: string | null;
    initialized: boolean;
    properties: HsmProperties;
}
export type HsmProperties = ZoneHsmProperties | MediaZoneHsmProperties | {};
export interface ZoneHsmProperties {
    zoneId: string;
    x: number;
    y: number;
    width: number;
    height: number;
    initialMediaStateId: string;
}
export interface MediaZoneHsmProperties extends ZoneHsmProperties {
    mediaStateIdToHState: LUT;
}
export interface HsmEventType {
    EventType: string;
    data?: any;
    EventData?: any;
}

export class HsmType {
    static Player: string;
    static VideoOrImages: string;
}

export class HStateType {
    static Top: string;
    static Player: string;
    static Playing: string;
    static Waiting: string;
    static Image: string;
    static Mrss: string;
    static Video: string;
    static SuperState: string;
}
export interface HState {
    id: string;
    type: HStateType;
    hsmId: string;
    superStateId: string;
    name: string;
}
export interface HStateSpecification {
    id: string;
    type: HStateType;
    hsmId: string;
    superStateId: string;
    name: string;
}
export interface MediaHState extends HState {
    mediaStateId: string;
    dataFeedId?: string;
    timeoutId?: number;
}
export interface HSMStateData {
    nextStateId: string | null;
}

export interface PlaybackState {
    videoElementRef: HTMLVideoElement | null;
}

export interface SubscribedEvents {
    [eventKey: string]: HState;
}
export interface ArState {
    bsdm?: DmState;
    hsm?: any;
    stateName?: string;
}

export interface PresentationDataState {
    runtimeEnvironment: RuntimeEnvironment;
    screenDimensions: Dimensions;
    srcDirectory: string;
    syncSpecFileMap: SyncSpecFileMap | null;
    autoSchedule: PpSchedule | null;
}
export interface SyncSpecFileMap {
    [name: string]: SyncSpecDownload;
}
export interface SyncSpecDownload {
    name: string;
    hash: SyncSpecHash;
    size: number;
    link: string;
}
interface SyncSpecHash {
    method: string;
    hex: string;
}
interface SyncSpecMeta {
    client: any;
    server: any;
}
export interface RawSyncSpecFiles {
    download: SyncSpecDownload[];
    ignore: any;
    delete: any;
}
export interface RawSyncSpec {
    meta: SyncSpecMeta;
    files: RawSyncSpecFiles;
}
export {};

export interface PpSchedule {
    scheduledPresentations: ScheduledPresentation[];
}
export interface ScheduledPresentation {
    presentationToSchedule: ScheduledPresentationFileData;
    presentationLocator: BsAssetLocator;
    dateTime: string;
    duration: number;
    allDayEveryDay: boolean;
    recurrence: boolean;
    recurrencePattern: string;
    recurrencePatternDaily: string;
    recurrencePatternDaysOfWeek: number;
    recurrenceStartDate: string;
    recurrenceGoesForever: boolean;
    recurrenceEndDate: string;
    interruption: boolean;
}
export interface ScheduledPresentationFileData {
    name: string;
    fileName: string;
    filePath: string;
}

export enum BsPpErrorType {
    unknownError = 0,
    unexpectedError = 1,
    invalidParameters = 2,
    invalidOperation = 3,
    apiError = 4,
    invalidModel = 5,
    invalidRemoteConfigurationFile = 6
}
export class BsPpError extends Error {
    name: string;
    type: BsPpErrorType;
    constructor(type: BsPpErrorType, reason?: string);
}
export function isBsPpError(error: Error): error is BsPpError;

/** @private */
export const isMac: () => boolean;
/** @private */
export const isPc: () => boolean;
/** @private */
export const isDesktop: () => boolean;
/** @private */
export const isBrowser: () => boolean;

export const isDevelopment: () => boolean;

/** @private */
export const postVideoEnd: () => any;

export const createHsm: (name: string, type: HsmType, properties: HsmProperties) => BsPpStringThunkAction;
export function initializeHsm(hsmId: string): BsPpVoidPromiseThunkAction;
export function constructorFunction(constructorHandler: () => void): void;
export function hsmDispatch(event: HsmEventType, hsmId: string, activeStateId: string | null): (dispatch: BsPpDispatch, getState: () => BsPpState) => void;

export const createHState: (type: string, hsmId: string, superStateId: string, name: string, options?: AddHStateOptions | undefined) => BsPpStringThunkAction;

export const mediaHStateEventHandler: (hState: HState, event: HsmEventType, stateData: HSMStateData) => BsPpVoidThunkAction;
export const mediaHStateExitHandler: (hStateId: string) => BsPpVoidThunkAction;
export const launchTimer: (hState: HState) => BsPpVoidThunkAction;

export const createMediaZoneHsm: (hsmName: string, hsmType: HsmType, bsdmZone: DmZone) => BsPpVoidThunkAction;
export const initializeVideoOrImagesZoneHsm: (hsmId: string) => BsPpVoidThunkAction;
export const videoOrImagesZoneHsmGetInitialState: (hsmId: string) => BsPpAnyPromiseThunkAction;

export const createMrssState: (hsmId: string, mediaState: DmMediaState, dataFeedId: string, superStateId: string) => BsPpStringThunkAction;
export const STMrssStateEventHandler: (hState: HState, event: HsmEventType, stateData: HSMStateData) => BsPpVoidThunkAction;

export const createPlayerHsm: () => any;
export const initializePlayerHsm: () => any;
export const playerHsmGetInitialState: () => BsPpAnyPromiseThunkAction;
export const STPlayerEventHandler: (hState: HState, event: HsmEventType, stateData: HSMStateData) => any;
export const STPlayingEventHandler: (hState: HState, event: HsmEventType, stateData: HSMStateData) => any;
export const STWaitingEventHandler: (hState: HState, event: HsmEventType, stateData: HSMStateData) => any;
export const launchSchedulePlayback: (presentationName: string) => BsPpVoidPromiseThunkAction;
export const launchPresentationPlayback: () => BsPpVoidThunkAction;
export const advanceToNextDataFeedInQueue: () => (dispatch: any, getState: any) => void;
export const queueRetrieveDataFeed: (bsdmDataFeedId: BsDmId) => (dispatch: any, getState: any) => void;
export const launchRetrieveFeedTimer: (dataFeedId: BsDmId) => any;

export const createZoneHsm: (hsmName: string, hsmType: HsmType, hsmData: HsmProperties) => BsPpStringThunkAction;

export const createImageState: (hsmId: string, mediaState: DmMediaState, superStateId: string) => BsPpStringThunkAction;
export const STImageStateEventHandler: (hState: HState, event: HsmEventType, stateData: HSMStateData) => BsPpVoidThunkAction;

export const createVideoState: (hsmId: string, mediaState: DmMediaState, superStateId: string) => BsPpStringThunkAction;
export const STVideoStateEventHandler: (hState: HState, event: HsmEventType, stateData: HSMStateData) => BsPpVoidThunkAction;

export const createSuperState: (hsmId: string, mediaState: DmMediaState, superStateId: string) => BsPpStringThunkAction;
export const STSuperStateEventHandler: (hState: HState, event: HsmEventType, stateData: HSMStateData) => BsPpVoidThunkAction;

export const newBsPpId: () => string;
export interface Dimensions {
    width: number;
    height: number;
}
export const calculateAspectRatioFit: (srcWidth: number, srcHeight: number, maxWidth: number, maxHeight: number) => Dimensions;

export function xmlStringToJson(xml: string): Promise<any>;

