// Generated by dts-bundle v0.7.3
// Dependencies for this module:
//   ../../redux
//   ../../@brightsign/bsdatamodel
//   ../../@brightsign/bscore

import { Action } from 'redux';
import { Dispatch } from 'redux';
import { ActionCreator } from 'redux';
import { Reducer } from 'redux';
import { DmState } from '@brightsign/bsdatamodel';
import { BsAssetLocator } from '@brightsign/bscore';

/** @module Model:index */

/** @module Types:index */

/** @module Model:base */
export const BRIGHTSIGN_PLAYER_MODEL_BATCH = "BRIGHTSIGN_PLAYER_MODEL_BATCH";
export const BRIGHTSIGN_PLAYER_MODEL_REHYDRATE = "BRIGHTSIGN_PLAYER_MODEL_REHYDRATE";
export const BRIGHTSIGN_PLAYER_MODEL_RESET = "BRIGHTSIGN_PLAYER_MODEL_RESET";
export type BsPpModelDispatch = Dispatch<any>;
export interface BsPpBaseAction extends Action {
    type: string;
    payload: {} | null;
    error?: boolean;
    meta?: {};
}
export interface BsPpAction<T> extends BsPpBaseAction {
    payload: T;
}
export type BsPpDispatch = Dispatch<BsPpState>;
export type BsPpVoidThunkAction = (dispatch: BsPpDispatch, getState: () => BsPpState, extraArgument: undefined) => void;
export type BsPpStringThunkAction = (dispatch: BsPpDispatch, getState: () => BsPpState, extraArgument: undefined) => string;
export type BsPpVoidPromiseThunkAction = (dispatch: BsPpDispatch, getState: () => BsPpState, extraArgument: undefined) => Promise<void>;
export type BsPpThunkAction<T> = (dispatch: BsPpDispatch, getState: () => BsPpState, extraArgument: undefined) => BsPpAction<T>;
export type BsPpAnyPromiseThunkAction = (dispatch: BsPpDispatch, getState: () => BsPpState, extraArgument: undefined) => Promise<any>;
export type BsPpActionCreator<T> = ActionCreator<BsPpAction<T>>;
export type BsPpModelThunkAction<T> = (dispatch: BsPpModelDispatch, getState: () => BsPpModelState, extraArgument: undefined) => T;
export const bsPpBatchAction: (action: BsPpBaseAction[]) => BsPpModelBatchAction;
export interface BsPpModelBatchAction extends Action {
    type: string;
    payload: BsPpBaseAction[];
}
export interface RehydrateBsPpModelParams {
    newBsBrightSignPlayerModelState: BsPpModelState;
}
export type RehydrateBsPpAction = BsPpAction<RehydrateBsPpModelParams>;
export const bsBrightSignPlayerRehydrateModel: (bsBrightSignPlayerState: BsPpModelState) => RehydrateBsPpAction;
export type ResetBsPpAction = BsPpAction<null>;
export const bsBrightSignPlayerResetModel: () => ResetBsPpAction;

/** @module Model:base */
/** @private */
export type BsBrightSignPlayerReducer = Reducer<BsPpModelState>;
/** @private */
export const enableBatching: (reduce: (state: BsPpModelState, action: BsPpBaseAction | BsPpModelBatchAction) => BsPpModelState) => BsBrightSignPlayerReducer;
export const bsPpReducer: Reducer<BsPpModelState>;
/** @private */
export function isValidBsBrightSignPlayerModelState(state: any): boolean;
/** @private */
export function isValidBsBrightSignPlayerModelStateShallow(state: any): boolean;

/** @module Model:template */
export const ADD_HSM: string;
export const UPDATE_HSM_PROPERTIES: string;
export const SET_HSM_TOP: string;
export const SET_HSM_INITIALIZED: string;
export const ADD_HSTATE = "ADD_HSTATE";
export const SET_MEDIA_H_STATE_TIMEOUT_ID = "SET_MEDIA_H_STATE_TIMEOUT_ID";
export const SET_ACTIVE_HSTATE = "SET_ACTIVE_HSTATE";
export const QUEUE_HSM_EVENT = "QUEUE_HSM_EVENT";
export const DEQUEUE_HSM_EVENT = "DEQUEUE_HSM_EVENT";
export type AddHsmAction = BsPpAction<Partial<Hsm>>;
export function addHsm(hsm: Hsm): AddHsmAction;
export interface HsmParams {
    id: string;
    zoneId?: string;
    x?: number;
    y?: number;
    width?: number;
    height?: number;
    initialMediaStateId?: string;
    mediaStateIdToHState?: LUT;
}
export type UpdateHsmPropertiesAction = BsPpAction<HsmParams>;
export function updateHsmProperties(params: HsmParams): UpdateHsmPropertiesAction;
export type SetHsmTopAction = BsPpAction<{}>;
export function setHsmTop(hsmId: string, topStateId: string): SetHsmTopAction;
export type SetHsmInitializedAction = BsPpAction<Partial<Hsm>>;
export function setHsmInitialized(id: string, initialized: boolean): SetHsmInitializedAction;
export type SetActiveHStateAction = BsPpAction<HState | null | any>;
export function setActiveHState(hsmId: string, activeState: HState | null): SetActiveHStateAction;
export type AddHStateAction = BsPpAction<{
    id: string;
    type: HStateType;
    hsmId: string;
    superStateId: string;
    name: string;
    mediaStateId?: string;
    timeoutId?: number;
}>;
export interface AddHStateOptions {
    mediaStateId: string;
    timeoutId?: number;
}
export function addHState(hStateSpecification: HStateSpecification, options?: AddHStateOptions): AddHStateAction;
export function setMediaHStateTimeoutId(hStateId: string, timeoutId: number): any;
export type HsmEventAction = BsPpAction<HsmEventType>;
export function queueHsmEvent(event: HsmEventType): HsmEventAction;
export function dequeueHsmEvent(): BsPpBaseAction;
export const hsmReducer: import("redux").Reducer<HsmState>;
/** @private */
export const isValidHsmState: (state: any) => boolean;

/** @module Types:base */
export type DeepPartial<T> = {
    [P in keyof T]?: DeepPartial<T[P]>;
};
export interface LUT {
    [key: string]: any;
}
export interface BsPpState {
    bsdm: DmState;
    bsPlayer: BsPpModelState;
}
export interface BsPpModelState {
    hsmState: HsmState;
    presentationData: PresentationDataState;
}
export interface BsPpBaseObject {
    id: string;
}
export interface BsPpMap<T extends BsPpBaseObject> {
    [id: string]: T;
}
export interface FileLUT {
    [fileName: string]: string;
}

export type HsmMap = BsPpMap<Hsm>;
export type HStateMap = BsPpMap<HState>;
export interface HsmState {
    hsmById: HsmMap;
    hStateById: HStateMap;
    hsmEventQueue: HsmEventType[];
}
export interface Hsm {
    id: string;
    name: string;
    type: HsmType;
    topStateId: string;
    activeStateId: string | null;
    initialized: boolean;
    properties: HsmProperties;
}
export type HsmProperties = ZoneHsmProperties | MediaZoneHsmProperties | {};
export interface ZoneHsmProperties {
    zoneId: string;
    x: number;
    y: number;
    width: number;
    height: number;
    initialMediaStateId: string;
}
export interface MediaZoneHsmProperties extends ZoneHsmProperties {
    mediaStateIdToHState: LUT;
}
export interface HsmEventType {
    EventType: string;
    data?: any;
    EventData?: any;
}

export class HsmType {
    static Player: string;
    static VideoOrImages: string;
}

export class HStateType {
    static Top: string;
    static Player: string;
    static Playing: string;
    static Waiting: string;
    static Image: string;
    static Video: string;
}
export interface HState {
    id: string;
    type: HStateType;
    hsmId: string;
    superStateId: string;
    name: string;
}
export interface HStateSpecification {
    id: string;
    type: HStateType;
    hsmId: string;
    superStateId: string;
    name: string;
}
export interface MediaHState extends HState {
    mediaStateId: string;
    timeoutId?: number;
}
export interface HSMStateData {
    nextStateId: string | null;
}

export interface SubscribedEvents {
    [eventKey: string]: HState;
}
export interface ArState {
    bsdm?: DmState;
    hsm?: any;
    stateName?: string;
}

export interface PresentationDataState {
    platform: string;
    srcDirectory: string;
    syncSpecFileMap: SyncSpecFileMap | null;
    autoSchedule: PpSchedule | null;
}
export interface SyncSpecFileMap {
    [name: string]: SyncSpecDownload;
}
export interface SyncSpecDownload {
    name: string;
    hash: SyncSpecHash;
    size: number;
    link: string;
}
interface SyncSpecHash {
    method: string;
    hex: string;
}
interface SyncSpecMeta {
    client: any;
    server: any;
}
export interface RawSyncSpecFiles {
    download: SyncSpecDownload[];
    ignore: any;
    delete: any;
}
export interface RawSyncSpec {
    meta: SyncSpecMeta;
    files: RawSyncSpecFiles;
}
export {};

export interface PpSchedule {
    scheduledPresentations: ScheduledPresentation[];
}
export interface ScheduledPresentation {
    presentationToSchedule: ScheduledPresentationFileData;
    presentationLocator: BsAssetLocator;
    dateTime: string;
    duration: number;
    allDayEveryDay: boolean;
    recurrence: boolean;
    recurrencePattern: string;
    recurrencePatternDaily: string;
    recurrencePatternDaysOfWeek: number;
    recurrenceStartDate: string;
    recurrenceGoesForever: boolean;
    recurrenceEndDate: string;
    interruption: boolean;
}
export interface ScheduledPresentationFileData {
    name: string;
    fileName: string;
    filePath: string;
}

